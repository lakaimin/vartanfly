<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Digital Mirror</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;700&family=Space+Grotesk:wght@300;500;700&display=swap" rel="stylesheet">
    
    <!-- MediaPipe Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #0b1120;
            font-family: 'Space Grotesk', 'Noto Sans TC', sans-serif;
            color: white;
            user-select: none;
            -webkit-user-select: none; /* iOS Safari */
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #input_video {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1.5rem; /* 手機版稍微縮小邊距 */
            box-sizing: border-box;
            background: radial-gradient(circle at center, transparent 0%, rgba(11, 17, 32, 0.8) 100%);
        }

        .interactive-element { pointer-events: auto; }

        .scan-line {
            position: absolute;
            width: 100%;
            height: 2px;
            background: rgba(56, 189, 248, 0.5);
            top: 0;
            left: 0;
            animation: scan 3s linear infinite;
            opacity: 0;
            z-index: 5;
            pointer-events: none;
        }
        
        .scanning .scan-line { opacity: 1; }

        @keyframes scan {
            0% { top: 0%; opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { top: 100%; opacity: 0; }
        }

        /* 按鈕群組樣式 */
        .btn-group {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            width: 100%;
        }

        .btn-tech {
            background: rgba(56, 189, 248, 0.1);
            border: 1px solid rgba(56, 189, 248, 0.3);
            color: #38bdf8;
            padding: 12px 24px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            cursor: pointer;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            min-width: 200px; /* 增加手機版按鈕寬度 */
        }

        /* 切換鏡頭按鈕 */
        .btn-icon-only {
            padding: 10px;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            min-width: auto;
            display: none; /* 預設隱藏，啟動後顯示 */
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.7);
        }

        .btn-tech:hover, .btn-tech:active {
            background: rgba(56, 189, 248, 0.2);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.4);
            transform: translateY(-2px);
        }

        .btn-tech:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #ef4444;
            margin-right: 8px;
            box-shadow: 0 0 5px #ef4444;
            transition: all 0.5s;
        }
        .status-dot.active {
            background-color: #22c55e;
            box-shadow: 0 0 5px #22c55e;
        }
        .status-dot.processing {
            background-color: #eab308;
            box-shadow: 0 0 5px #eab308;
            animation: pulse 1s infinite;
        }
        .status-dot.simulation {
            background-color: #a855f7;
            box-shadow: 0 0 5px #a855f7;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .hud-corner {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.5s;
        }
        .tl { top: 20px; left: 20px; border-right: none; border-bottom: none; }
        .tr { top: 20px; right: 20px; border-left: none; border-bottom: none; }
        .bl { bottom: 20px; left: 20px; border-right: none; border-top: none; }
        .br { bottom: 20px; right: 20px; border-left: none; border-top: none; }

        .active-face .hud-corner {
            border-color: rgba(56, 189, 248, 0.6);
            width: 60px;
            height: 60px;
        }
        
        .simulation-mode .hud-corner { border-color: rgba(168, 85, 247, 0.6); }
        .simulation-mode .scan-line { background: rgba(168, 85, 247, 0.5); }

        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            width: 90%;
            max-width: 500px;
        }
        #loader.show { opacity: 1; pointer-events: auto; }
        
        #error-card {
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid #ef4444;
            padding: 20px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: left;
            display: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            pointer-events: auto;
        }

        .error-title { color: #ef4444; font-weight: bold; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;}
        .error-desc { color: #cbd5e1; font-size: 0.85rem; line-height: 1.5; font-family: sans-serif; }
        .error-hint { color: #94a3b8; font-size: 0.75rem; margin-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px;}

        /* Header Layout Optimization */
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
        }

    </style>
</head>
<body class="">

    <div class="scan-line"></div>
    
    <video id="input_video" playsinline autoplay muted></video>

    <div id="canvas-container">
        <canvas id="output_canvas"></canvas>
    </div>

    <div id="ui-layer">
        <div class="hud-corner tl"></div>
        <div class="hud-corner tr"></div>
        <div class="hud-corner bl"></div>
        <div class="hud-corner br"></div>

        <header class="header-container">
            <div>
                <h1 class="text-xl md:text-2xl font-bold tracking-widest text-white/90">DIGITAL MIRROR</h1>
                <div class="flex items-center mt-2 text-xs font-mono text-white/50">
                    <div id="status-dot" class="status-dot"></div>
                    <span id="status-text">SYSTEM STANDBY</span>
                </div>
            </div>
            
            <div class="flex flex-col items-end gap-2">
                <!-- 資訊顯示 -->
                <div class="text-right hidden md:block text-xs font-mono text-white/40">
                    MODE: <span id="mode-display">IDLE</span><br>
                    FPS: <span id="fps-display">--</span>
                </div>
                
                <!-- 切換鏡頭按鈕 (預設隱藏) -->
                <button id="switchCamBtn" class="btn-tech btn-icon-only interactive-element" onclick="switchCamera()">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                        <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                    </svg>
                </button>
            </div>
        </header>

        <div id="loader">
            <div id="loader-spinner">
                <div class="text-cyan-400 text-4xl mb-2 animate-bounce">▪ ▪ ▪</div>
                <p id="loader-text" class="text-xs tracking-widest uppercase">Initializing Neural Link...</p>
            </div>

            <!-- 錯誤訊息卡片 -->
            <div id="error-card">
                <div class="error-title">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/></svg>
                    連接失敗 / Connection Failed
                </div>
                <div class="error-desc" id="error-msg-content">無法存取相機。</div>
                <div class="error-hint">
                    建議方案：<br>
                    1. 手機請使用 Chrome (Android) 或 Safari (iOS)。<br>
                    2. 若使用 Line/FB 開啟，請切換至瀏覽器。<br>
                    3. 嘗試「滑鼠模擬模式」測試互動。
                </div>
                <div class="flex gap-2 mt-4 justify-end flex-wrap">
                    <button class="btn-tech btn-secondary flex-1" onclick="retryCamera()">重試</button>
                    <button class="btn-tech flex-1" onclick="startSimulationMode()">模擬模式</button>
                </div>
            </div>
        </div>

        <footer class="flex justify-center md:justify-end pb-8 md:pb-0">
            <div class="btn-group" id="controls">
                <button id="startBtn" class="btn-tech interactive-element" onclick="startCameraDirect()">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M10.5 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0z"/>
                        <path d="M0 8s3-5.5 8-5.5S16 8 16 8s-3 5.5-8 5.5S0 8 0 8zm8 3.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"/>
                    </svg>
                    啟動 (Start)
                </button>
            </div>
        </footer>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const switchCamBtn = document.getElementById('switchCamBtn');
        const controls = document.getElementById('controls');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const modeDisplay = document.getElementById('mode-display');
        const loader = document.getElementById('loader');
        const loaderSpinner = document.getElementById('loader-spinner');
        const errorCard = document.getElementById('error-card');
        const errorMsgContent = document.getElementById('error-msg-content');
        const body = document.body;

        let width, height;
        let isRunning = false;
        let isSimulation = false;
        let currentFacingMode = 'user'; // 預設前鏡頭
        let currentStream = null;

        let robotState = {
            eyeOpenLeft: 1.0, eyeOpenRight: 1.0, mouthSmile: 0, mouthOpen: 0,
            headX: 0.5, headY: 0.5, tilt: 0, detected: false,
            lerp: { eyeL: 1, eyeR: 1, mouthS: 0, mouthO: 0, hX: 0.5, hY: 0.5, tilt: 0 }
        };
        let mouse = { x: 0.5, y: 0.5 };
        let autoBlinkTimer = 0;

        function resize() {
            width = canvasElement.width = window.innerWidth;
            height = canvasElement.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end;
        }

        // --- 繪圖邏輯 (保持原樣) ---
        function drawRobot(state) {
            canvasCtx.fillStyle = '#0b1120';
            canvasCtx.fillRect(0, 0, width, height);
            
            canvasCtx.strokeStyle = isSimulation ? 'rgba(168, 85, 247, 0.05)' : 'rgba(56, 189, 248, 0.05)';
            drawGrid(state);

            if (!state.detected) {
                drawStandbyIcon();
                return;
            }

            const cx = width * state.lerp.hX;
            const cy = height * state.lerp.hY;
            const scale = Math.min(width, height) * 0.4;

            canvasCtx.save();
            canvasCtx.translate(cx, cy);
            canvasCtx.rotate(state.lerp.tilt);

            const mainColor = isSimulation ? '#a855f7' : '#00f3ff';
            const lightColor = isSimulation ? '#f3e8ff' : '#ccfbf1';

            const eyeSpacing = scale * 0.35;
            const eyeWidth = scale * 0.25;
            const eyeHeight = scale * 0.2;
            
            drawEye(-eyeSpacing, -scale * 0.1, eyeWidth, eyeHeight * state.lerp.eyeL, mainColor, lightColor);
            drawEye(eyeSpacing, -scale * 0.1, eyeWidth, eyeHeight * state.lerp.eyeR, mainColor, lightColor);
            drawDigitalMouth(0, scale * 0.25, scale * 0.5, state.lerp.mouthO, state.lerp.mouthS, mainColor, lightColor);

            canvasCtx.restore();
        }

        function drawGrid(state) {
            canvasCtx.lineWidth = 1;
            const gridSize = 50;
            const offsetX = (state.lerp.hX - 0.5) * -50;
            const offsetY = (state.lerp.hY - 0.5) * -50;

            for (let x = offsetX % gridSize; x < width; x += gridSize) {
                canvasCtx.beginPath();
                canvasCtx.moveTo(x, 0);
                canvasCtx.lineTo(x, height);
                canvasCtx.stroke();
            }
            for (let y = offsetY % gridSize; y < height; y += gridSize) {
                canvasCtx.beginPath();
                canvasCtx.moveTo(0, y);
                canvasCtx.lineTo(width, y);
                canvasCtx.stroke();
            }
        }

        function drawStandbyIcon() {
            const time = Date.now() * 0.002;
            const cx = width / 2;
            const cy = height / 2;
            const radius = 30 + Math.sin(time) * 5;
            canvasCtx.beginPath();
            canvasCtx.arc(cx, cy, radius, 0, Math.PI * 2);
            canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            canvasCtx.stroke();
            canvasCtx.beginPath();
            canvasCtx.arc(cx, cy, 4, 0, Math.PI * 2);
            canvasCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            canvasCtx.fill();
        }

        function drawEye(x, y, w, h, shadowColor, fillColor) {
            canvasCtx.save();
            canvasCtx.translate(x, y);
            canvasCtx.shadowBlur = 20;
            canvasCtx.shadowColor = shadowColor;
            canvasCtx.beginPath();
            let drawH = Math.max(h, 4); 
            canvasCtx.moveTo(-w/2, 0);
            canvasCtx.lineTo(-w/3, -drawH/2);
            canvasCtx.lineTo(w/3, -drawH/2);
            canvasCtx.lineTo(w/2, 0);
            canvasCtx.lineTo(w/3, drawH/2);
            canvasCtx.lineTo(-w/3, drawH/2);
            canvasCtx.closePath();
            canvasCtx.fillStyle = fillColor;
            canvasCtx.fill();
            if (h > 10) {
                canvasCtx.shadowBlur = 0;
                canvasCtx.fillStyle = '#0f172a';
                canvasCtx.beginPath();
                canvasCtx.arc(0, 0, h * 0.3, 0, Math.PI*2);
                canvasCtx.fill();
            }
            canvasCtx.restore();
        }

        function drawDigitalMouth(x, y, w, openAmt, smileAmt, shadowColor, strokeColor) {
            canvasCtx.save();
            canvasCtx.translate(x, y);
            canvasCtx.shadowBlur = 15;
            canvasCtx.shadowColor = shadowColor;
            canvasCtx.strokeStyle = strokeColor;
            canvasCtx.lineWidth = 4;
            canvasCtx.lineCap = 'round';
            canvasCtx.lineJoin = 'round';
            const mw = w;
            const cornerY = -smileAmt * 20; 
            const openY = openAmt * 50; 
            canvasCtx.beginPath();
            canvasCtx.moveTo(-mw/2, cornerY);
            canvasCtx.quadraticCurveTo(0, 0, mw/2, cornerY);
            if (openAmt > 0.1) {
                canvasCtx.quadraticCurveTo(0, openY, -mw/2, cornerY);
                canvasCtx.fillStyle = isSimulation ? 'rgba(168, 85, 247, 0.1)' : 'rgba(0, 243, 255, 0.1)';
                canvasCtx.fill(); 
            }
            canvasCtx.stroke();
            canvasCtx.restore();
        }

        // --- MediaPipe ---
        const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
        faceMesh.setOptions({maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        
        faceMesh.onResults((results) => {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                updateRobotStateFromFace(landmarks);
            } else {
                robotState.detected = false;
                statusText.innerText = "SEARCHING FACE...";
                statusDot.className = "status-dot processing";
            }
        });

        function updateRobotStateFromFace(landmarks) {
            robotState.detected = true;
            robotState.headX = 1 - landmarks[1].x; 
            robotState.headY = landmarks[1].y;
            
            const leftEyeDist = Math.abs(landmarks[159].y - landmarks[145].y);
            robotState.eyeOpenLeft = leftEyeDist > 0.01 ? 1 : 0.1;
            const rightEyeDist = Math.abs(landmarks[386].y - landmarks[374].y);
            robotState.eyeOpenRight = rightEyeDist > 0.01 ? 1 : 0.1;

            const mouthH = Math.abs(landmarks[13].y - landmarks[14].y);
            const mouthW = Math.abs(landmarks[61].x - landmarks[291].x);
            robotState.mouthOpen = Math.min(Math.max((mouthH / mouthW) * 2, 0), 1.5);

            const cornerY = (landmarks[61].y + landmarks[291].y) / 2;
            const lipY = landmarks[13].y;
            robotState.mouthSmile = Math.max(-0.5, Math.min((lipY - cornerY) * 100, 1.5));

            const dx = landmarks[33].x - landmarks[263].x;
            const dy = landmarks[33].y - landmarks[263].y;
            robotState.tilt = Math.atan2(dy, dx) + Math.PI;

            body.classList.add('scanning');
            body.classList.add('active-face');
            statusText.innerText = "LINK ESTABLISHED";
            statusDot.className = "status-dot active";
        }

        // --- Camera Control ---

        async function startCameraDirect() {
            if (isRunning && !isSimulation) return;
            resetUI();
            
            // UI Update
            loader.classList.add('show');
            loaderSpinner.style.display = 'block';
            errorCard.style.display = 'none';
            statusDot.className = "status-dot processing";
            controls.style.display = 'none';

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                handleError({ name: "NotSupported", message: "瀏覽器不支援相機 API" });
                return;
            }

            try {
                // 如果之前有串流，先停止
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }

                // 請求相機 (使用 currentFacingMode)
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: currentFacingMode 
                    }
                });

                currentStream = stream;
                videoElement.srcObject = stream;
                
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    isRunning = true;
                    isSimulation = false;
                    
                    // UI State
                    loader.classList.remove('show');
                    statusText.innerText = "CAMERA ONLINE";
                    modeDisplay.innerText = currentFacingMode === 'user' ? "FRONT CAM" : "REAR CAM";
                    switchCamBtn.style.display = 'block'; // 顯示切換按鈕
                    
                    processVideo();
                    loop();
                };
            } catch (err) {
                handleError(err);
            }
        }

        // 切換鏡頭功能
        async function switchCamera() {
            if (!isRunning || isSimulation) return;
            
            // Toggle mode
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            
            // Restart camera
            statusText.innerText = "SWITCHING...";
            await startCameraDirect();
        }

        function retryCamera() {
            startCameraDirect();
        }

        // --- Simulation Mode ---
        function startSimulationMode() {
            isSimulation = true;
            isRunning = true;
            controls.style.display = 'none';
            switchCamBtn.style.display = 'none'; // 隱藏相機切換
            loader.classList.remove('show');
            errorCard.style.display = 'none';
            
            statusText.innerText = "SIMULATION ONLINE";
            statusDot.className = "status-dot simulation";
            modeDisplay.innerText = "MOUSE MODE";
            body.classList.add('active-face');
            body.classList.add('simulation-mode');
            
            window.addEventListener('mousemove', (e) => {
                mouse.x = e.clientX / window.innerWidth;
                mouse.y = e.clientY / window.innerHeight;
            });
            // 手機觸控支援模擬
            window.addEventListener('touchmove', (e) => {
                 if(e.touches.length > 0) {
                    mouse.x = e.touches[0].clientX / window.innerWidth;
                    mouse.y = e.touches[0].clientY / window.innerHeight;
                 }
            });
            
            window.addEventListener('mousedown', () => robotState.mouthOpen = 1.0);
            window.addEventListener('mouseup', () => robotState.mouthOpen = 0);
            window.addEventListener('touchstart', () => robotState.mouthOpen = 1.0);
            window.addEventListener('touchend', () => robotState.mouthOpen = 0);

            loop();
        }

        function updateSimulation() {
            robotState.detected = true;
            robotState.headX = mouse.x;
            robotState.headY = mouse.y;
            robotState.tilt = (mouse.x - 0.5) * 0.5;
            
            autoBlinkTimer++;
            if (autoBlinkTimer > 200 + Math.random() * 100) {
                robotState.eyeOpenLeft = 0.1;
                robotState.eyeOpenRight = 0.1;
                if (autoBlinkTimer > 210) autoBlinkTimer = 0;
            } else {
                robotState.eyeOpenLeft = 1.0;
                robotState.eyeOpenRight = 1.0;
            }

            if (mouse.y > 0.6) robotState.mouthSmile = 1.0;
            else robotState.mouthSmile = 0;
        }

        async function processVideo() {
            if (!isRunning || isSimulation) return;
            await faceMesh.send({image: videoElement});
            requestAnimationFrame(processVideo);
        }

        function loop() {
            if (isSimulation) updateSimulation();

            const s = 0.2;
            robotState.lerp.eyeL += (robotState.eyeOpenLeft - robotState.lerp.eyeL) * s;
            robotState.lerp.eyeR += (robotState.eyeOpenRight - robotState.lerp.eyeR) * s;
            robotState.lerp.mouthO += (robotState.mouthOpen - robotState.lerp.mouthO) * s;
            robotState.lerp.mouthS += (robotState.mouthSmile - robotState.lerp.mouthS) * s;
            robotState.lerp.hX += (robotState.headX - robotState.lerp.hX) * 0.1;
            robotState.lerp.hY += (robotState.headY - robotState.lerp.hY) * 0.1;
            robotState.lerp.tilt += (robotState.tilt - robotState.lerp.tilt) * 0.1;

            drawRobot(robotState);
            requestAnimationFrame(loop);
        }

        function resetUI() {
            controls.style.display = 'flex';
        }

        function handleError(err) {
            console.error(err);
            loaderSpinner.style.display = 'none';
            errorCard.style.display = 'block';
            
            let msg = "未知錯誤";
            if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                msg = "相機存取被拒絕。請檢查瀏覽器權限 (網址列鎖頭圖示)。";
            } else if (err.name === 'NotFoundError') {
                msg = "找不到相機裝置。";
            } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
                msg = "相機無法讀取。可能正被其他程式 (Zoom/Meet) 佔用，或權限受阻。";
            } else if (err.name === 'OverconstrainedError') {
                msg = "找不到符合的前/後鏡頭，請切換鏡頭試試。";
            }
            errorMsgContent.innerText = msg;
        }

        // Init
        drawRobot(robotState);

    </script>
</body>
</html>